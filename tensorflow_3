#coding:UTF-8
#预测多或的结果一样
#导入模块，生成数据集
import tensorflow as tf
import numpy as np
BATCH_SIZE=8
seed=233455

rdm=np.randmon.RandomState(seed)
X = rdm.rand(32,2)
Y_= [[x1+x2+(rdm.rand()/10.0+0.05)] for (x1,x2) in X]

#1.定义神经网络的输入，参数和输出，定义前向传播过程
x = tf.placeholder(tf.float32,shape=(None,2))
y_= tf.placeholder(tf.float32,shape=(None,2))
w1=tf.Variable(tf.random_normal([2,1],stddev=1,seed=1))
y=tf.matmul(x,w1)

#定义损失函数为MSE，及反向传播方法为梯度下降。
loss_mse = tf.reduce_mean(tf.square(y_-y))
train_step=tf.train.GradientDescentOptimizer(0.001).minimize(loss_mse)

#生成会话，训练STEPS轮
with tf.Session() as sess:
    init_op=tf.global_variables_initlizer()
    sess.run(init_op)
    STEPS = 20000
    for i in range(STEPS):
        start=(i*BATCH_SIZE)%32
        end=start+BATCH_SIZE
        sess.run(train_step,feed.dict={x:X[start:edt],y_:Y_[start:end]})
        if i%500 == 0:
            print "训练 %d 轮以后，w1是"%(i)
            print sess.run(w1)
    print "最终w1为" sess.run(w1)
